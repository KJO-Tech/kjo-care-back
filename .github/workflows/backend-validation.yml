name: Spring Microservices CI

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Create .env file with repository secrets
        run: |
          cat > .env << EOL
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          KEYCLOAK_ADMIN=${{ secrets.KEYCLOAK_ADMIN }}
          KEYCLOAK_ADMIN_PASSWORD=${{ secrets.KEYCLOAK_ADMIN_PASSWORD }}
          KEYCLOAK_SERVER_URL=${{ secrets.KEYCLOAK_SERVER_URL }}
          KEYCLOAK_REALM=${{ secrets.KEYCLOAK_REALM }}
          KEYCLOAK_MASTER_REALM=${{ secrets.KEYCLOAK_MASTER_REALM }}
          KEYCLOAK_ADMIN_CLIENT=${{ secrets.KEYCLOAK_ADMIN_CLIENT }}
          KEYCLOAK_CLIENT_SECRET=${{ secrets.KEYCLOAK_CLIENT_SECRET }}
          KEYCLOAK_HOSTNAME=${{ secrets.KEYCLOAK_HOSTNAME }}
          KEYCLOAK_CLIENT_ID=${{ secrets.KEYCLOAK_CLIENT_ID }}
          EOL

      - name: Start essential services first
        run: |
          # Iniciar primero los servicios esenciales para reducir logs
          docker compose up -d postgres keycloak config-server eureka-server
          echo "Esperando a que los servicios esenciales inicien..."
          
          # Esperar a que postgres esté listo
          timeout 120 bash -c 'until docker inspect --format="{{.State.Health.Status}}" postgres 2>/dev/null | grep -q "healthy"; do sleep 5; echo "Esperando a postgres..."; done'
          echo "Postgres está listo"
          
          # Esperar a que config-server esté listo
          timeout 120 bash -c 'until docker inspect --format="{{.State.Health.Status}}" config-server 2>/dev/null | grep -q "healthy"; do sleep 5; echo "Esperando a config-server..."; done'
          echo "Config server está listo"
          
          # Esperar a que eureka-server esté listo
          timeout 120 bash -c 'until docker inspect --format="{{.State.Health.Status}}" eureka-server 2>/dev/null | grep -q "healthy"; do sleep 5; echo "Esperando a eureka-server..."; done'
          echo "Eureka server está listo"
          
          # Esperar a que keycloak esté listo
          timeout 180 bash -c 'until docker inspect --format="{{.State.Health.Status}}" keycloak 2>/dev/null | grep -q "healthy"; do sleep 5; echo "Esperando a keycloak..."; done'
          echo "Keycloak está listo"

      - name: Start microservices
        run: |
          # Iniciar los microservicios uno por uno para reducir logs
          microservices=("msvc-auth" "msvc-users" "msvc-mood-tracking" "msvc-emergency" "msvc-blog")
          
          for service in "${microservices[@]}"; do
            echo "Iniciando $service..."
            docker compose up -d $service
            sleep 15  # Dar tiempo a que el servicio inicie
          
            if ! docker ps | grep -q "$service"; then
              echo "Error: El servicio $service no se inició correctamente"
              docker logs --tail 50 $service
              exit 1
            fi
            echo "$service iniciado correctamente"
          done

      - name: Start gateway
        run: |
          echo "Iniciando gateway..."
          docker compose up -d gateway
          sleep 15
          
          if ! docker ps | grep -q "gateway"; then
            echo "Error: El gateway no se inició correctamente"
            docker logs --tail 50 gateway
            exit 1
          fi
          echo "Gateway iniciado correctamente"

      - name: Verify service health
        run: |
          # Verificar estado de todos los servicios
          services=("config-server" "eureka-server" "msvc-auth" "msvc-users" "msvc-mood-tracking" "msvc-emergency" "msvc-blog" "gateway" "keycloak" "postgres")
          
          echo "Estado de los contenedores:"
          docker ps
          
          for service in "${services[@]}"; do
            if ! docker ps | grep -q "$service"; then
              echo "Error: El servicio $service no está ejecutándose"
              docker logs --tail 50 $service
              exit 1
            else
              echo "✅ $service está en ejecución"
            fi
          done

      - name: Test Eureka Registry
        run: |
          # Verificar que los servicios estén registrados en Eureka
          echo "Verificando registro en Eureka..."
          
          # Esperar un tiempo para que los servicios se registren
          sleep 30
          
          # Obtener apps registradas en Eureka
          EUREKA_RESPONSE=$(curl -s http://localhost:8761/eureka/apps)
          
          # Guardar la respuesta en un archivo para depuración
          echo "$EUREKA_RESPONSE" > eureka_response.xml
          
          # Servicios que deben estar registrados
          services=("MSVC-AUTH" "MSVC-USERS" "MSVC-MOOD-TRACKING" "MSVC-EMERGENCY" "MSVC-BLOG" "GATEWAY")
          
          for service in "${services[@]}"; do
            if echo "$EUREKA_RESPONSE" | grep -q "$service"; then
              echo "✅ $service está registrado en Eureka"
            else
              echo "❌ $service NO está registrado en Eureka"
              # No fallamos el build por esto, ya que puede ser una condición intermedia
              # exit 1
            fi
          done

      - name: Test Gateway Routes
        run: |
          # Verificar que el gateway esté enrutando correctamente
          echo "Verificando rutas del gateway..."
          
          BASE_URL="http://localhost:8080/api/mind"
          routes=("auth" "users" "mood-tracking" "emergency" "blog")
          
          for route in "${routes[@]}"; do
            echo "Verificando ruta a $route..."
            # Verificar el endpoint de health o un endpoint básico
            URL="$BASE_URL/$route/actuator/health"
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" $URL)
          
            # Algunos servicios pueden requerir autenticación, así que aceptamos códigos 2xx, 3xx y 4xx
            if [ "$STATUS_CODE" -ge 200 ] && [ "$STATUS_CODE" -lt 500 ]; then
              echo "✅ Ruta a $route funciona (código: $STATUS_CODE)"
            else
              echo "❌ Ruta a $route falló (código: $STATUS_CODE)"
              docker logs --tail 50 gateway
              # No fallamos el build por esto, algunos servicios pueden requerir autenticación
              # exit 1
            fi
          done

      - name: Cleanup
        if: always()
        run: docker compose down -v